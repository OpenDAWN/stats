<!doctype html>
<meta charset="utf-8"/>

<script src="./bundle.js"></script>
<script>
	var q = require('queried');
	var on = require('emmy/on');
	var Draggable = require('draggy');
</script>

<style>
	.play {
		display: block;
		width: 40px;
		height: 40px;
		border: 0;
		background: none;
		text-align: center;
	}
	.play:after{
		content: "▶"
	}
	.play-pause:after{
		content: "❙❙";
		letter-spacing: -.5rem;
		margin-left: -.7rem;
	}
</style>

<section>
	<audio src="./assets/chopin.mp3" class="audio"></audio>
	<button class="play"></button>
	<input class="frequency" type="number" value="5000" min="0" max="20000"/>
	<input class="Q" type="number" value="5" min="0" max="100"/>
</section>

<script>
	var ctx = new AudioContext();

	//Bind play button
	var playBtn = q('.play');
	var audioEl = q('.audio');
	var freqEl = q('.frequency');
	var qEl = q('.Q');

	on(playBtn, 'click', function () {
		if (audioEl.paused) {
			audioEl.play();
			playBtn.classList.add('play-pause');
		}
		else {
			audioEl.pause();
			playBtn.classList.remove('play-pause');
		}
	});


	//Create generator node
	var oscNode = ctx.createOscillator();
	oscNode.type = 'sine';
	oscNode.frequency.value = 5000;
	oscNode.start();
	on(freqEl, 'change', function () {
		oscNode.frequency.value = this.value;
	});


	//Create volume controller
	var gainNode = ctx.createGain();
	gainNode.gain.value = 1; //1000000000;


	//Hook up painter
	var Stats = require('web-audio-stats');
	var stats = new Stats(gainNode, ctx);
	playBtn.parentNode.appendChild(stats.element);


	//Make draggable
	new Draggable(stats.element);


	//Create filter processor
	var scriptNode = ctx.createScriptProcessor(4096, 1, 1);

	//buffers memory - last 2 items
	var xm1 = [0,0], xm2 = [0,0], ym1 = [0,0], ym2 = [0,0];

	//lpf params
	var	Q = 5,
	f0 = 5000,	w0,	alpha, b0, b1, b2, a0, a1, a2;

	calcFilterCoefs();
	function calcFilterCoefs() {
		w0 = 2*Math.PI*f0/ctx.sampleRate,
		alpha = Math.sin(w0)/(2*Q),
		b0 =  (1 - Math.cos(w0))/2,
		b1 =   1 - Math.cos(w0),
		b2 =  (1 - Math.cos(w0))/2,
		a0 =   1 + alpha,
		a1 =  -2 * Math.cos(w0),
		a2 =   1 - alpha;
	}

	//change params
	on(qEl, 'change', function () {
		Q = this.value;
		calcFilterCoefs();
	});
	on(freqEl, 'change', function () {
		f0 = this.value;
		calcFilterCoefs();
	});

	//process
	on(scriptNode, 'audioprocess', function (e) {
		var inputBuffer = e.inputBuffer;
		var outputBuffer = e.outputBuffer;


		// Loop through the output channels (in this case there is only one)
		for (var channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
			var x = inputBuffer.getChannelData(channel);
			var y = outputBuffer.getChannelData(channel);

			// Loop through the 1024 samples
			for (var n = 0, xn1, xn2, yn1, yn2; n < inputBuffer.length; n++) {
				// make output equal to the same as the input
				// y[n] = x[n];

				//basic filter formula
				// http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
				xn1 = n === 0 ? xm1[channel] : x[n-1];
				xn2 = n === 0 ? xm2[channel] : n === 1 ? xm1[channel] : x[n-2];
				yn1 = n === 0 ? ym1[channel] : y[n-1];
				yn2 = n === 0 ? ym2[channel] : n === 1 ? ym1[channel] : y[n-2];

				y[n] = (b0/a0)*x[n] + (b1/a0)*xn1 + (b2/a0)*xn2
									- (a1/a0)*yn1 - (a2/a0)*yn2;

				// add noise to each output sample
				// outputData[n] += Math.random() * .01;
			}

			//save buffer memory
			xm1[channel] = x[x.length - 1];
			xm2[channel] = x[x.length - 2];
			ym1[channel] = y[y.length - 1];
			ym2[channel] = y[y.length - 2];
		}

	});





	//Connect audio nodes
	var sourceNode = ctx.createMediaElementSource(audioEl);
	// oscNode.connect(scriptNode);
	sourceNode.connect(scriptNode);
	scriptNode.connect(gainNode);
	stats.connect(ctx.destination);
</script>